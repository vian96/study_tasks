
// DEF_CMD_ (num, name, args, code)

// TODO make numbers more clear ?

DEF_CMD_ (1, PUSH, 1, {PUSH (ARG);})

DEF_CMD_ (2, IN, 0, {PUSH (input_int ());})

DEF_CMD_ (3, MUL, 0, {PUSH (POP * POP);})

DEF_CMD_ (4, OUT, 0, {printf ("OUT: %d\n", POP);})

DEF_CMD_ (5, ADD, 0, {PUSH (POP + POP);})

DEF_CMD_ (6, POP, 1, {ARG = POP;})

DEF_CMD_ (7, JMP, 1, {JUMP (ARG);})

// equal
DEF_CMD_ (8, JE, 1, {if (POP == POP) JUMP (ARG);})

// deeper is greater than higher
DEF_CMD_ (9, JA, 1, {
    int a_ = POP; int b_ = POP; 
    if (a_ < b_) 
        JUMP (ARG);
})

// higher is greater than deeper
DEF_CMD_ (10, JB, 1, {
    int a_ = POP; int b_ = POP; 
    if (a_ > b_) 
        JUMP (ARG);
})

DEF_CMD_ (11, SQRT, 0, {
    int x_ = POP;
    if (x_ < 0) 
        printf ("ERROR: Calculating sqaure root from negative value, pushing nothing");
    else
        PUSH (sqrt (x_));
})

// deeper / higher
DEF_CMD_ (12, DIV, 0, {
    int a_ = POP; int b_ = POP; 
    if (a_ == 0)
        printf ("ERROR: division by zero, pushing nothing\n");
    PUSH (b_ / a_);
})

DEF_CMD_ (13, RET, 0, {JUMP (POP);})

DEF_CMD_ (14, CALL, 1, {
    PUSH (cpu->ip + SIZE_ARG); 
    JUMP (ARG);
})

DEF_CMD_ (15, PRINT, 0, {
    char buffer__[PIXEL_X * PIXEL_Y + 100] = {};
    int cnt = 0;

    for (int y = 0; y < PIXEL_Y; y++) {
        for (int x = 0; x < PIXEL_X; x++)
            buffer__[cnt++] = cpu->ram[VID_RAM + y * PIXEL_X + x] ? '*' : ' ';
        buffer__[cnt++] = '\n';
    }

    buffer__[cnt - 1] = '\0'; // TODO why cnt-1?
    fputs (buffer__, stdout);
    Sleep (60);
})

// deeper % higher
DEF_CMD_ (16, MOD, 0, {
    int a_ = POP; int b_ = POP; 
    PUSH (b_ % a_);
})

DEF_CMD_ (17, JNE, 1, {if (POP != POP) JUMP (ARG);})

DEF_CMD_ (18, MEMSET, 1, {
    int right__ = POP;
    int left__ = POP;
    int val__ = ARG;
    
    if (left__ < 0 || right__ <= left__) {
        printf ("Wrong args %d and %d of MEMSET at pos %d", left__, right__, cpu->ip);
        break;
    }

    for (int i = left__; i < right__; i++) 
        cpu->ram[i] = val__;
})

DEF_CMD_ (19, DUMP, 1, {cpu_dump (stdout, cpu, ARG);})

